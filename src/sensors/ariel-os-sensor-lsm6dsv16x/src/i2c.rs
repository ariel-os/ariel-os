//! Driver for the sensor used over I2C.

use ariel_os_sensors::{
    Category, Label, MeasurementUnit, Sensor,
    sensor::{
        Mode as SensorMode, ReadingChannel, ReadingChannels, ReadingError, ReadingResult,
        ReadingWaiter, Sample, Samples, SetModeError, State, TriggerMeasurementError,
    },
    signal::Signal as ReadingSignal,
};
use ariel_os_sensors_utils::AtomicState;
use embassy_sync::{
    blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex, once_lock::OnceLock, signal::Signal,
};
use embassy_time::Timer;
use embedded_hal_async::i2c::I2c;
use portable_atomic::{AtomicU8, Ordering};

use crate::{AccelMode, AccelOdr, GyroMode, GyroOdr, PART_NUMBER, Register};

/// I2C address of the sensor device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
pub enum I2cAddress {
    /// The SA0 pin is pulled low.
    Sa0Gnd = 0b1101010,
    #[default]
    /// The SA0 pin is pulled high.
    Sa0Vdd = 0b1101011,
}

/// Configuration of the sensor driver and device.
#[derive(Debug, Default)]
#[non_exhaustive]
pub struct Config {
    /// I2C address to use.
    pub address: I2cAddress,
}

ariel_os_hal::define_peripherals!(
    /// Peripherals required by the sensor driver.
    Peripherals {}
);

/// Driver to use an LSM6DSV16X over I2C.
pub struct Lsm6dsv16x<I2C> {
    state: AtomicState,
    label: Option<&'static str>,
    i2c: OnceLock<Mutex<CriticalSectionRawMutex, I2C>>,
    address: AtomicU8,
    signaling: Signal<CriticalSectionRawMutex, ()>,
    reading: ReadingSignal<ReadingResult<Samples>>,
}

impl<I2C: I2c + Send> Lsm6dsv16x<I2C> {
    /// Creates an uninitialized driver.
    #[expect(clippy::new_without_default)]
    #[must_use]
    pub const fn new(label: Option<&'static str>) -> Self {
        Self {
            state: AtomicState::new(State::Uninitialized),
            label,
            i2c: OnceLock::new(),
            address: AtomicU8::new(I2cAddress::Sa0Vdd as u8),
            signaling: Signal::new(),
            reading: ReadingSignal::new(),
        }
    }

    /// Initializes the driver.
    pub async fn init(
        &'static self,
        _peripherals: Peripherals,
        mut i2c_device: I2C,
        config: Config,
    ) {
        if !self.i2c.is_set() {
            self.address.store(config.address as u8, Ordering::Release);

            let res = i2c_device
                .write(
                    config.address as u8,
                    &[Register::Ctrl3 as u8, crate::SW_RESET_BITS],
                )
                .await;

            if res.is_err() {
                return;
            }

            let _ = self.i2c.init(Mutex::new(i2c_device));

            self.state.set(State::Enabled);
        }
    }

    /// Listens for measurement requests generated by [`Lsm6dsv16x::trigger_measurement()`], and
    /// responds to them.
    /// This should be called before [`Lsm6dsv16x::wait_for_reading()`], as that method will otherwise
    /// not be able to respond to measurement requests from [`Lsm6dsv16x::trigger_measurement()`].
    ///
    /// # Note
    ///
    /// [`Lsm6dsv16x::init()`] needs to be called and `await`ed before calling this method.
    pub async fn run(&'static self) -> ! {
        loop {
            self.signaling.wait().await;

            if self.state.get() == State::Sleeping {
                let _ = self.power_down().await;
                continue;
            }

            self.reading.signal(self.measure().await);
        }
    }

    async fn measure(&'static self) -> ReadingResult<Samples> {
        let mut i2c = self.i2c.get().await.lock().await;
        let address = self.address.load(Ordering::Acquire);

        // Trigger acceleration and gyroscope measurement.
        let ctrl1 = AccelMode::HighPerformance as u8 | AccelOdr::_1_92kHz as u8;
        let ctrl2 = GyroMode::HighPerformance as u8 | GyroOdr::_1_92kHz as u8;
        i2c.write(address, &[Register::Ctrl1 as u8, ctrl1, ctrl2])
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        // Wait for the measurements.
        loop {
            let mut buf = [0u8];
            i2c.write_read(address, &[Register::StatusReg as u8], &mut buf)
                .await
                .map_err(|_| ReadingError::SensorAccess)?;

            // New data available.
            let mask = crate::GDA_BITS | crate::XLDA_BITS;
            if buf[0] & mask == mask {
                break;
            }

            // TODO: configuration
            Timer::after_millis(10).await;
        }

        // Read all angular velocity and acceleration registers.
        let mut buf = [0u8; 2 * 6];
        i2c.write_read(address, &[Register::OutxLG as u8], &mut buf)
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        let accel_sensitivity = crate::AccelFullScale::_2g.as_sensitivity_thousandths();
        let accel_x =
            i32::from(i16::from_be_bytes([buf[7], buf[6]])) * i32::from(accel_sensitivity);
        let accel_y =
            i32::from(i16::from_be_bytes([buf[9], buf[8]])) * i32::from(accel_sensitivity);
        let accel_z =
            i32::from(i16::from_be_bytes([buf[11], buf[10]])) * i32::from(accel_sensitivity);

        let accel_accuracy = crate::accel_accuracy();

        let gyro_scale = crate::GyroFullScale::_125dps.as_sensitivity_hundredths();
        let gyro_x = i32::from(i16::from_be_bytes([buf[1], buf[0]])) * i32::from(gyro_scale);
        let gyro_y = i32::from(i16::from_be_bytes([buf[3], buf[2]])) * i32::from(gyro_scale);
        let gyro_z = i32::from(i16::from_be_bytes([buf[5], buf[4]])) * i32::from(gyro_scale);

        let gyro_accuracy = crate::gyro_accuracy();

        let samples = Samples::from_6(
            self,
            [
                Sample::new(accel_x, accel_accuracy),
                Sample::new(accel_y, accel_accuracy),
                Sample::new(accel_z, accel_accuracy),
                Sample::new(gyro_x, gyro_accuracy),
                Sample::new(gyro_y, gyro_accuracy),
                Sample::new(gyro_z, gyro_accuracy),
            ],
        );

        Ok(samples)
    }

    // TODO: test this
    async fn power_down(&self) -> Result<(), ReadingError> {
        let accel_power_down = AccelMode::HighPerformance as u8 | AccelOdr::PowerDown as u8;
        let gyro_power_down = GyroMode::Sleep as u8 | GyroOdr::PowerDown as u8;

        let mut i2c = self.i2c.get().await.lock().await;
        let address = self.address.load(Ordering::Acquire);
        i2c.write(
            address,
            &[Register::Ctrl1 as u8, accel_power_down, gyro_power_down],
        )
        .await
        .map_err(|_| ReadingError::SensorAccess)
    }
}

impl<I2C: Send> Sensor for Lsm6dsv16x<I2C> {
    fn trigger_measurement(&self) -> Result<(), TriggerMeasurementError> {
        match self.state.get() {
            State::Measuring => {
                self.reading.clear();
            }
            State::Enabled => {
                self.state.set(State::Measuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return Err(TriggerMeasurementError::NonEnabled);
            }
        }

        self.signaling.signal(());

        Ok(())
    }

    fn wait_for_reading(&'static self) -> ReadingWaiter {
        match self.state.get() {
            State::Measuring => {
                self.state.set(State::Enabled);

                ReadingWaiter::new(self.reading.wait())
            }
            State::Enabled => {
                return ReadingWaiter::new_err(ReadingError::NotMeasuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return ReadingWaiter::new_err(ReadingError::NonEnabled);
            }
        }
    }

    fn set_mode(&self, mode: SensorMode) -> Result<State, SetModeError> {
        let new_state = self.state.set_mode(mode);

        if new_state == State::Uninitialized {
            Err(SetModeError::Uninitialized)
        } else {
            Ok(new_state)
        }
    }

    fn state(&self) -> State {
        self.state.get()
    }

    fn categories(&self) -> &'static [Category] {
        &[
            Category::Accelerometer,
            Category::AccelerometerGyroscope,
            Category::Gyroscope,
        ]
    }

    fn reading_channels(&self) -> ReadingChannels {
        ReadingChannels::from([
            ReadingChannel::new(Label::AccelerationX, -6, MeasurementUnit::AccelG),
            ReadingChannel::new(Label::AccelerationY, -6, MeasurementUnit::AccelG),
            ReadingChannel::new(Label::AccelerationZ, -6, MeasurementUnit::AccelG),
            ReadingChannel::new(
                Label::AngularVelocityX,
                -5,
                MeasurementUnit::DegreePerSecond,
            ),
            ReadingChannel::new(
                Label::AngularVelocityY,
                -5,
                MeasurementUnit::DegreePerSecond,
            ),
            ReadingChannel::new(
                Label::AngularVelocityZ,
                -5,
                MeasurementUnit::DegreePerSecond,
            ),
        ])
    }

    fn label(&self) -> Option<&'static str> {
        self.label
    }

    fn display_name(&self) -> Option<&'static str> {
        Some("6-axis IMU")
    }

    fn part_number(&self) -> Option<&'static str> {
        Some(PART_NUMBER)
    }

    fn version(&self) -> u8 {
        0
    }
}
