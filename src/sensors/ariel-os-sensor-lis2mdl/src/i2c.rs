//! Driver for the sensor used over I2C.

use ariel_os_sensors::{
    Category, Label, MeasurementUnit, Sensor,
    sensor::{
        Mode as SensorMode, ReadingChannel, ReadingChannels, ReadingError, ReadingResult,
        ReadingWaiter, Sample, Samples, SetModeError, State, TriggerMeasurementError,
    },
    signal::Signal as ReadingSignal,
};
use ariel_os_sensors_utils::AtomicState;
use embassy_sync::{
    blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex, once_lock::OnceLock, signal::Signal,
};
use embassy_time::Timer;
use embedded_hal_async::i2c::I2c;

use crate::{PART_NUMBER, Register, TARGET_I2C_ADDR};

/// Configuration of the sensor driver and device.
#[derive(Debug, Default)]
#[non_exhaustive]
pub struct Config {}

ariel_os_hal::define_peripherals!(
    /// Peripherals required by the sensor driver.
    Peripherals {}
);

/// Driver to use an LIS2MDL over I2C.
pub struct Lis2mdl<I2C> {
    state: AtomicState,
    label: Option<&'static str>,
    i2c: OnceLock<Mutex<CriticalSectionRawMutex, I2C>>,
    signaling: Signal<CriticalSectionRawMutex, ()>,
    reading: ReadingSignal<ReadingResult<Samples>>,
}

impl<I2C: I2c + Send> Lis2mdl<I2C> {
    /// Creates an uninitialized driver.
    #[must_use]
    pub const fn new(label: Option<&'static str>) -> Self {
        Self {
            state: AtomicState::new(State::Uninitialized),
            label,
            i2c: OnceLock::new(),
            signaling: Signal::new(),
            reading: ReadingSignal::new(),
        }
    }

    /// Initializes the driver.
    pub async fn init(
        &'static self,
        _peripherals: Peripherals,
        mut i2c_device: I2C,
        _config: Config,
    ) {
        if !self.i2c.is_set() {
            if Self::reset(&mut i2c_device).await.is_err() {
                return;
            }

            let _ = self.i2c.init(Mutex::new(i2c_device));

            self.state.set(State::Enabled);
        }
    }

    /// Resets the sensor device.
    ///
    /// # Errors
    ///
    /// Returns `Err(())` in case of a communication error with the sensor device.
    async fn reset(i2c_device: &mut I2C) -> Result<(), ()> {
        let cfg = crate::SOFT_RST_BITS;
        i2c_device
            .write(TARGET_I2C_ADDR, &[Register::CfgRegA as u8, cfg])
            .await
            .map_err(|_| ())?;

        // Software reset can take 5 microseconds (AN5069 §7).
        Timer::after_micros(10).await;

        // Always enable Block Data Update.
        let cfg = crate::BDU_BITS;
        i2c_device
            .write(TARGET_I2C_ADDR, &[Register::CfgRegC as u8, cfg])
            .await
            .map_err(|_| ())?;

        // We do not enable offset cancellation as we use single mode and cannot guarantee that
        // measurements will be triggered frequently enough, which could lead to incorrect readings
        // (AN5069 §8).
        // If measurements are indeed carried out frequently, this can result in greater power
        // consumption than if offset cancellation were enabled.
        // A configuration setting could be later added to control this, which should also be taken
        // into account for the turn-on time (Table 8).

        Ok(())
    }

    /// Listens for measurement requests generated by [`Lis2mdl::trigger_measurement()`], and
    /// responds to them.
    /// This should be called before [`Lis2mdl::wait_for_reading()`], as that method will otherwise
    /// not be able to respond to measurement requests from [`Lis2mdl::trigger_measurement()`].
    ///
    /// # Note
    ///
    /// [`Lis2mdl::init()`] needs to be called and `await`ed before calling this method.
    pub async fn run(&'static self) -> ! {
        loop {
            self.signaling.wait().await;

            self.reading.signal(self.measure().await);
        }
    }

    /// Triggers a measurement and asynchronously returns the readings when available.
    ///
    /// # Errors
    ///
    /// Returns `ReadingError::SensorAccess` in case of a communication error with the sensor
    /// device.
    async fn measure(&'static self) -> ReadingResult<Samples> {
        let mut i2c = self.i2c.get().await.lock().await;

        // Trigger a one-shot measurement.
        let cfg = crate::COMP_TEMP_EN_BITS | crate::Md::SingleMode as u8;
        i2c.write(TARGET_I2C_ADDR, &[Register::CfgRegA as u8, cfg])
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        // Wait for the measurement.
        loop {
            // The typical time for generation is 9.4 ms at most, as offset cancellation is not
            // enabled (AN5069 §3.3 and Table 8).
            Timer::after_millis(10).await;

            let mut buf = [0u8];
            i2c.write_read(TARGET_I2C_ADDR, &[Register::StatusReg as u8], &mut buf)
                .await
                .map_err(|_| ReadingError::SensorAccess)?;

            // New data available.
            let mask = crate::ZYXDA_BITS;
            if buf[0] & mask == mask {
                break;
            }
        }

        // Read XYZ registers.
        let mut buf = [0u8; 3 * 2];
        i2c.write_read(TARGET_I2C_ADDR, &[Register::OutxLReg as u8], &mut buf)
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        // Sensitivity is 1.5 (Table 2 of the datasheet).
        let mag_x = i32::from(i16::from_be_bytes([buf[1], buf[0]])) * 3 / 2;
        let mag_y = i32::from(i16::from_be_bytes([buf[3], buf[2]])) * 3 / 2;
        let mag_z = i32::from(i16::from_be_bytes([buf[5], buf[4]])) * 3 / 2;

        let mag_accuracy = crate::accuracy();

        let samples = Samples::from_3(
            self,
            [
                Sample::new(mag_x, mag_accuracy),
                Sample::new(mag_y, mag_accuracy),
                Sample::new(mag_z, mag_accuracy),
            ],
        );

        Ok(samples)
    }
}

impl<I2C: Send> Sensor for Lis2mdl<I2C> {
    fn trigger_measurement(&self) -> Result<(), TriggerMeasurementError> {
        self.reading.clear();

        match self.state.get() {
            State::Measuring => {}
            State::Enabled => {
                self.state.set(State::Measuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return Err(TriggerMeasurementError::NonEnabled);
            }
        }

        self.signaling.signal(());

        Ok(())
    }

    fn wait_for_reading(&'static self) -> ReadingWaiter {
        match self.state.get() {
            State::Measuring => {
                self.state.set(State::Enabled);

                ReadingWaiter::new(self.reading.wait())
            }
            State::Enabled => ReadingWaiter::new_err(ReadingError::NotMeasuring),
            State::Uninitialized | State::Disabled | State::Sleeping => {
                ReadingWaiter::new_err(ReadingError::NonEnabled)
            }
        }
    }

    fn set_mode(&self, mode: SensorMode) -> Result<State, SetModeError> {
        let new_state = self.state.set_mode(mode);

        if new_state == State::Uninitialized {
            Err(SetModeError::Uninitialized)
        } else {
            Ok(new_state)
        }
    }

    fn state(&self) -> State {
        self.state.get()
    }

    fn categories(&self) -> &'static [Category] {
        &[Category::Magnetometer]
    }

    fn reading_channels(&self) -> ReadingChannels {
        ReadingChannels::from([
            ReadingChannel::new(
                Label::X,
                -7, // milligauss
                MeasurementUnit::Tesla,
            ),
            ReadingChannel::new(
                Label::Y,
                -7, // milligauss
                MeasurementUnit::Tesla,
            ),
            ReadingChannel::new(
                Label::Z,
                -7, // milligauss
                MeasurementUnit::Tesla,
            ),
        ])
    }

    fn label(&self) -> Option<&'static str> {
        self.label
    }

    fn display_name(&self) -> Option<&'static str> {
        Some("3-axis magnetometer")
    }

    fn part_number(&self) -> Option<&'static str> {
        Some(PART_NUMBER)
    }

    fn version(&self) -> u8 {
        0
    }
}
